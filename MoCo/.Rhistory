# motion-controlled association
round(result$adj_association, 4)
# z-scores
round(result$z_score, 4)
# computing motion-controlled average functional connectivity and associations
begin_time = Sys.time()
result = moco(
X = data$X,
Z = data$Z,
A = data$A,
M = data$M,
Y = data$Y,
Delta_M = data$Delta_M,
Delta_Y = data$Delta_Y,
SL_library = c("SL.mean", "SL.glm","SL.glm.interaction"),
glm_formula = list(pMX = ".",
pMXZ = "."),
HAL_pMX = FALSE,
HAL_pMXZ = FALSE,
cross_fit = TRUE,
cv_folds = 5,
seed_rgn = 2,
test = TRUE,
fwer = 0.05
)
end_time = Sys.time()
begin_time - end_time
# inspect the result
str(result)
# motion-controlled average functional connectivity
round(result$est, 4)
# motion-controlled association
round(result$adj_association, 4)
# computing motion-controlled average functional connectivity and associations
begin_time = Sys.time()
result = moco(
X = data$X,
Z = data$Z,
A = data$A,
M = data$M,
Y = data$Y,
Delta_M = data$Delta_M,
Delta_Y = data$Delta_Y,
SL_library = c("SL.mean", "SL.glm","SL.glm.interaction"),
glm_formula = list(pMX = ".",
pMXZ = "."),
HAL_pMX = FALSE,
HAL_pMXZ = FALSE,
cross_fit = TRUE,
cv_folds = 5,
seed_rgn = 123,
test = TRUE,
fwer = 0.05
)
end_time = Sys.time()
begin_time - end_time
# inspect the result
str(result)
# motion-controlled average functional connectivity
round(result$est, 4)
# motion-controlled association
round(result$adj_association, 4)
# z-scores
round(result$z_score, 4)
R.version.string
packageVersion("ica")
packageVersion("far")
packageVersion("MASS")
V = 50
S1 = S2 = S3 = matrix(0,ncol = V,nrow = V)
S1[5:20,5:20] = 4;S1[23:37,23:37] = 3;S1[40:48,40:48] = 3
S2[15:20,] = -3;S2[,15:20] = -3
S3[15:25,36:45] = 3; S3[36:45,15:25] = 3
Struth = rbind(Ltrans(S1,FALSE) , Ltrans(S2,FALSE), Ltrans(S3,FALSE))
Ltrans<-function(X,d=TRUE){ X[upper.tri(X,d)]  }
Ltrinv<-function(x,V,d=TRUE){ Y = matrix(0,ncol = V,nrow = V);
Y[upper.tri(Y,d)]=x;return(Y + t(Y) -d*diag(diag(Y)))  }
V = 50
S1 = S2 = S3 = matrix(0,ncol = V,nrow = V)
S1[5:20,5:20] = 4;S1[23:37,23:37] = 3;S1[40:48,40:48] = 3
S2[15:20,] = -3;S2[,15:20] = -3
S3[15:25,36:45] = 3; S3[36:45,15:25] = 3
Struth = rbind(Ltrans(S1,FALSE) , Ltrans(S2,FALSE), Ltrans(S3,FALSE))
plot(S1)
plot.mat(S1)
library(plot.matrix)
plot(S1)
plot(S1)
plot(S2)
plot(S3)
plot(S1, border=NA)
plot(S1, border=NA, key=NULL)
plot(S1, border=NA, key=NULL, axis.col=NULL, axis.row=NULL)
plot(S1, border=NA, key=NULL, axis.col=NULL, axis.row=NULL, xlab='', ylab='')
plot(S1, border=NA, key=NULL, axis.col=NULL, axis.row=NULL, xlab='', ylab='', col=c('#f2a900', '#007dba'))
plot(S1, border=NA, key=NULL, axis.col=NULL, axis.row=NULL, xlab='', ylab='', col=c('#007dba', '#f2a900'))
plot(S1, border=NA, key=NULL, axis.col=NULL, axis.row=NULL, xlab='', ylab='', col=c('#007dba', '#b58500'))
plot(S1, border=NA, key=NULL, axis.col=NULL, axis.row=NULL, xlab='', ylab='', col=c('#007dba', '#84754e'))
plot(S1, border=NA, key=NULL, axis.col=NULL, axis.row=NULL, xlab='', ylab='', col=c('#007dba', '#F5B7B1'))
plot(S1, border=NA, key=NULL, axis.col=NULL, axis.row=NULL, xlab='', ylab='', col=c('#007dba', '#F1948A'))
plot(S1, border=NA, key=NULL, axis.col=NULL, axis.row=NULL, xlab='', ylab='', col=c('#007dba', '#F1948A'))
plot(S2, border=NA, key=NULL, axis.col=NULL, axis.row=NULL, xlab='', ylab='', col=c('#007dba', '#F1948A'))
plot(S3, border=NA, key=NULL, axis.col=NULL, axis.row=NULL, xlab='', ylab='', col=c('#007dba', '#F1948A'))
plot(S2, border=NA, key=NULL, axis.col=NULL, axis.row=NULL, xlab='', ylab='', col=c('#007dba', '#F1948A'))
plot(S1, border=NA, key=NULL, axis.col=NULL, axis.row=NULL, xlab='', ylab='', col=c('#007dba', '#F1948A'))
plot(S2, border=NA, key=NULL, axis.col=NULL, axis.row=NULL, xlab='', ylab='', col=c('#F1948A', '#007dba'))
plot(S3, border=NA, key=NULL, axis.col=NULL, axis.row=NULL, xlab='', ylab='', col=c('#007dba', '#F1948A'))
plot(S1, border=NA, key=NULL, axis.col=NULL, axis.row=NULL, xlab='', ylab='', col=c('#007dba', '#F1C40F'))
plot(S1, border=NA, key=NULL, axis.col=NULL, axis.row=NULL, xlab='', ylab='', col=c('#007dba', '#F39C12'))
plot(S1, border=NA, key=NULL, axis.col=NULL, axis.row=NULL, xlab='', ylab='', col=c('#007dba', '#EC7063'))
plot(S1, border=NA, key=NULL, axis.col=NULL, axis.row=NULL, xlab='', ylab='', col=c('#007dba', '#F1948A'))
plot(S2, border=NA, key=NULL, axis.col=NULL, axis.row=NULL, xlab='', ylab='', col=c('#F1948A', '#007dba'))
plot(S3, border=NA, key=NULL, axis.col=NULL, axis.row=NULL, xlab='', ylab='', col=c('#007dba', '#F1948A'))
plot(S2, border=NA, key=NULL, axis.col=NULL, axis.row=NULL, xlab='', ylab='', col=c('#F1948A', '#007dba'))
plot(S3, border=NA, key=NULL, axis.col=NULL, axis.row=NULL, xlab='', ylab='', col=c('#007dba', '#F1948A'))
set.seed(100)
Atruth = matrix(rnorm(100*3),nrow=100,ncol=3)
Residual = matrix(rnorm(100*dim(Struth)[2]),nrow=100)
Yraw = Atruth%*%Struth + Residual
## Run Locus on the data
Locus_result = LOCUS(Yraw,3,V)
library(LOCUS
)
## Run Locus on the data
Locus_result = LOCUS(Yraw,3,V)
## Visualize the result
par(mfrow=c(2,3))
for(i in 1:dim(Struth)[1]){image(Ltrinv(Struth[i,],V,FALSE))}
for(i in 1:dim(Locus_result$S)[1]){image(Ltrinv(Locus_result$S[i,],V,FALSE))}
``` r
# library
library(LOCUS)
# Simulated the data to use
V = 50
S1 = S2 = S3 = matrix(0,ncol = V,nrow = V)
S1[5:20,5:20] = 4;S1[23:37,23:37] = 3;S1[40:48,40:48] = 3
S2[15:20,] = -3;S2[,15:20] = -3
S3[15:25,36:45] = 3; S3[36:45,15:25] = 3
Struth = rbind(Ltrans(S1,FALSE) , Ltrans(S2,FALSE), Ltrans(S3,FALSE))
set.seed(100)
Atruth = matrix(rnorm(100*3),nrow=100,ncol=3)
Residual = matrix(rnorm(100*dim(Struth)[2]),nrow=100)
Yraw = Atruth%*%Struth + Residual
# visualize source signal
par(mfrow=c(1,3))
for(i in 1:dim(Struth)[1]){image(Ltrinv(Struth[i,],V,FALSE))}
## Run Locus on the data
Locus_result = LOCUS(Yraw,3,V)
## Visualize the result
par(mfrow=c(1,3))
for(i in 1:dim(Locus_result$S)[1]){image(Ltrinv(Locus_result$S[i,],V,FALSE))}
V = 50
S1 = S2 = S3 = matrix(0,ncol = V,nrow = V)
S1[5:20,5:20] = 4;S1[23:37,23:37] = 3;S1[40:48,40:48] = 3
S2[15:20,] = -3;S2[,15:20] = -3
S3[15:25,36:45] = 3; S3[36:45,15:25] = 3
Struth = rbind(Ltrans(S1,FALSE) , Ltrans(S2,FALSE), Ltrans(S3,FALSE))
set.seed(1)
Atruth = matrix(rnorm(100*3),nrow=100,ncol=3)
Residual = matrix(rnorm(100*dim(Struth)[2]),nrow=100)
Yraw = Atruth%*%Struth + Residual
## Run Locus on the data
Locus_result = LOCUS(Yraw,3,V)
## Visualize the result
par(mfrow=c(2,3))
V = 50
S1 = S2 = S3 = matrix(0,ncol = V,nrow = V)
S1[5:20,5:20] = 4;S1[23:37,23:37] = 3;S1[40:48,40:48] = 3
S2[15:20,] = -3;S2[,15:20] = -3
S3[15:25,36:45] = 3; S3[36:45,15:25] = 3
Struth = rbind(Ltrans(S1,FALSE) , Ltrans(S2,FALSE), Ltrans(S3,FALSE))
set.seed(1)
Atruth = matrix(rnorm(100*3),nrow=100,ncol=3)
Residual = matrix(rnorm(100*dim(Struth)[2]),nrow=100)
Yraw = Atruth%*%Struth + Residual
## Run Locus on the data
Locus_result = LOCUS(Yraw,3,V)
set.seed(2)
Atruth = matrix(rnorm(100*3),nrow=100,ncol=3)
Residual = matrix(rnorm(100*dim(Struth)[2]),nrow=100)
Yraw = Atruth%*%Struth + Residual
## Run Locus on the data
Locus_result = LOCUS(Yraw,3,V)
## Visualize the result
par(mfrow=c(2,3))
for(i in 1:dim(Struth)[1]){image(Ltrinv(Struth[i,],V,FALSE))}
for(i in 1:dim(Locus_result$S)[1]){image(Ltrinv(Locus_result$S[i,],V,FALSE))}
set.seed(22)
Atruth = matrix(rnorm(100*3),nrow=100,ncol=3)
Residual = matrix(rnorm(100*dim(Struth)[2]),nrow=100)
Yraw = Atruth%*%Struth + Residual
## Run Locus on the data
Locus_result = LOCUS(Yraw,3,V)
## Visualize the result
par(mfrow=c(2,3))
for(i in 1:dim(Struth)[1]){image(Ltrinv(Struth[i,],V,FALSE))}
for(i in 1:dim(Locus_result$S)[1]){image(Ltrinv(Locus_result$S[i,],V,FALSE))}
set.seed(100)
Atruth = matrix(rnorm(100*3),nrow=100,ncol=3)
Residual = matrix(rnorm(100*dim(Struth)[2]),nrow=100)
Yraw = Atruth%*%Struth + Residual
## Run Locus on the data
Locus_result = LOCUS(Yraw,3,V)
## Visualize the result
par(mfrow=c(2,3))
for(i in 1:dim(Struth)[1]){image(Ltrinv(Struth[i,],V,FALSE))}
for(i in 1:dim(Locus_result$S)[1]){image(Ltrinv(Locus_result$S[i,],V,FALSE))}
for(i in c(3, 1, 2)){image(Ltrinv(Locus_result$S[i,],V,FALSE))}
for(i in 1:dim(Struth)[1]){image(Ltrinv(Struth[i,],V,FALSE))}
image(Ltrinv(Locus_result$S[3,],V,FALSE))
image(Ltrinv(Locus_result$S[1,],V,FALSE))
image(Ltrinv(Locus_result$S[2,],V,FALSE))
image(Ltrinv(Locus_result$S[3,],V,FALSE))
image(Ltrinv(-Locus_result$S[1,],V,FALSE))
image(Ltrinv(-Locus_result$S[2,],V,FALSE))
for(i in 1:dim(Struth)[1]){image(Ltrinv(Struth[i,],V,FALSE))}
image(Ltrinv(Locus_result$S[3,],V,FALSE))
image(Ltrinv(-Locus_result$S[1,],V,FALSE))
image(Ltrinv(-Locus_result$S[2,],V,FALSE))
image(Ltrinv(Locus_result$S[3,],V,FALSE))
image(Ltrinv(-Locus_result$S[1,],V,FALSE))
image(Ltrinv(-Locus_result$S[2,],V,FALSE))
image(Ltrinv(Locus_result$S[3,],V,FALSE))
image(Ltrinv(-Locus_result$S[1,],V,FALSE))
image(Ltrinv(-Locus_result$S[2,],V,FALSE))
par(mfrow=c(1,3))
image(Ltrinv(Locus_result$S[3,],V,FALSE))
image(Ltrinv(-Locus_result$S[1,],V,FALSE))
image(Ltrinv(-Locus_result$S[2,],V,FALSE))
# libraries
library(ggplot2)
library(ggthemes)
library(gridExtra)
library(lattice)
# node mode(each node's mode, in total 264 nodes)
node.mode = read.table("/Users/scarlett_ran/Library/CloudStorage/Dropbox/LOCUS/data/pnc\ data/roi_id.txt")
node.mode = node.mode$V1
modID = data.frame(id = 0:10, modname = c("Other","med vis","op vis","lat vis","DMN","CB","SM","Aud","EC","FPR","FPL"))
## change order
# 1-3 6 7 4 8 10  9 5  0 orig
# 1-3 4 5 6 7  8  9 10 11 new
modname.new = c("med vis","op vis","lat vis","SM","Aud","DMN","EC","FPL","FPR","CB","Other")
ids = sapply(c(0,6,7,4,8,10,5), match, x = node.mode, nomatch = 0)
for(i in 5:8){
node.mode[which(ids[,i-3]==1)] = i-1
}
node.mode[which(ids[,1] == 1)] = 11
node.mode[which(ids[,6] == 1)] = 8
node.mode[which(ids[,7] == 1)] = 10
# count the number of nodes <=i (sum up each mode)
k = 0
grid.mode = vector()
count.mode = table(node.mode)
for(i in 1:(length(count.mode)-1)){
k = k + count.mode[i]
grid.mode[i] = k
}
V = 264
loc = (c(grid.mode, V) + c(0, grid.mode))/2
# plot the latent source based on source specific color bar
re.mod = function(Mat){
Mat = as.matrix(Mat)
return(Mat[order(node.mode),order(node.mode)])  # determines S's layout
}
Ltrans = function(X, d = T){ X[upper.tri(X,d)]  }
Ltrinv = function(x, V, d = T){
Y = matrix(0,ncol = V,nrow = V)
Y[upper.tri(Y,d)]=x
return(Y + t(Y) -d*diag(diag(Y)))
}
levelplotX = function(X, maint="", p = 0.99, colbar=T, li=NULL){
if(is.null(li)){
li= quantile(abs(X),probs=p)
}
p1 = levelplot(re.mod(Ltrinv(X,V,F)),
col.regions = colorRampPalette(c("blue","white", "red"))(1e3),
at = c(-Inf, do.breaks(c(-li,li), 100), Inf), panel = function(...){
panel.levelplot(...)
panel.abline(v=grid.mode+1, col="black")
panel.abline(h=grid.mode+1, col="black")},
scales=list(x=list(rot=65,at=loc+1,labels=modname.new,cex=1.05),y=list(at=loc+1,labels=modname.new,cex=1.05)),
xlab="",ylab="",main=maint,colorkey=colbar,
par.settings=list(axis.text=list(fontfamily="Arial"),
par.main.text=list(fontfamily="Arial")))
return(p1)
}
# plot result
setwd("/Users/scarlett_ran/Library/CloudStorage/Dropbox/dFC/analysis/result/decomposition/static")
load("result_q30.RData")
theta = result$theta
S = result$S
# latent source at each group each time point
plots_scan = lapply(1:q, function(r){
if(r %in% c(3, 18, 29)){
levelplotX(S[r,], maint = paste0("Source ", r), p = 0.99)
}else{
levelplotX(S[r,], maint = paste0("Source ", r), p = 0.99)
}
})
# arrange the plots together
nrow_ = 4
# latent source at each group each time point
plots_scan = lapply(1:q, function(r){
if(r %in% c(3, 18, 29)){
levelplotX(-S[r,], maint = paste0("Source ", r), p = 0.99)
}else{
levelplotX(S[r,], maint = paste0("Source ", r), p = 0.99)
}
})
# plot result
setwd("/Users/scarlett_ran/Library/CloudStorage/Dropbox/dFC/analysis/result/decomposition/static")
load("result_q30.RData")
theta = result$theta
S = result$S
# latent source at each group each time point
plots_scan = lapply(1:30, function(r){
if(r %in% c(3, 18, 29)){
levelplotX(-S[r,], maint = paste0("Source ", r), p = 0.99)
}else{
levelplotX(S[r,], maint = paste0("Source ", r), p = 0.99)
}
})
# arrange the plots together
nrow_ = 4
ncol_ = 5
g = do.call(arrangeGrob, c(plots_scan, nrow = nrow_, ncol = ncol_))
# plot result
setwd("/Users/scarlett_ran/Library/CloudStorage/Dropbox/dFC/analysis/result/decomposition/static")
load("result_q30.RData")
theta = result$theta
S = result$S
# latent source at each group each time point
plots_scan = lapply(1:30, function(r){
if(r %in% c(3, 18, 29)){
levelplotX(-S[r,], maint = paste0("Source ", r), p = 0.99)
}else{
levelplotX(S[r,], maint = paste0("Source ", r), p = 0.99)
}
})
# arrange the plots together
nrow_ = 5
ncol_ = 6
g = do.call(arrangeGrob, c(plots_scan, nrow = nrow_, ncol = ncol_))
# determine image dimensions
width = 30
height = 25
ggsave(filename = "plot.png", g, width = width, height = height)
load('/Users/scarlett_ran/Library/CloudStorage/Dropbox/1\ project\ 3/tutorial/data/data_seed12236.Rdata')
mean(data$Delta_Y)
100*(1-mean(data$Delta_Y))
load('/Users/scarlett_ran/Library/CloudStorage/Dropbox/1\ project\ 3/tutorial/data/data_seed15120.Rdata')
100*(1-mean(data$Delta_Y))
load('/Users/scarlett_ran/Library/CloudStorage/Dropbox/1\ project\ 3/tutorial/data/data_seed13326.Rdata')
100*(1-mean(data$Delta_Y))
load('/Users/scarlett_ran/Library/CloudStorage/Dropbox/1\ project\ 3/tutorial/data/data_seed18578.Rdata')
100*(1-mean(data$Delta_Y))
load('/Users/scarlett_ran/Library/CloudStorage/Dropbox/1\ project\ 3/tutorial/data/data_seed16086.Rdata')
100*(1-mean(data$Delta_Y))
# library
library(MoCo)
library(SuperLearner)
load("/Users/scarlett_ran/Library/CloudStorage/Dropbox/1\ project\ 3/tutorial/data/data.RData")
# inspect data
str(data)
# library
library(MoCo)
library(SuperLearner)
# inspect data
str(data)
# computing motion-controlled average functional connectivity and associations
begin_time = Sys.time()
result = moco(
X = data$X,
Z = data$Z,
A = data$A,
M = data$M,
Y = data$Y,
Delta_M = data$Delta_M,
Delta_Y = data$Delta_Y,
SL_library = c("SL.mean", "SL.glm","SL.glm.interaction"),
glm_formula = list(pMX = ".",
pMXZ = "."),
HAL_pMX = FALSE,
HAL_pMXZ = FALSE,
cross_fit = TRUE,
cv_folds = 5,  # 5
seed_rgn = 1, # 123
test = TRUE,
fwer = 0.05
)
end_time = Sys.time()
begin_time - end_time
# inspect the result
str(result)
# motion-controlled average functional connectivity
round(result$est, 4)
# motion-controlled association
round(result$adj_association, 4)
# z-scores
round(result$z_score, 4)
# significant regions
result$significant_regions
# set working directory
setwd("/Users/scarlett_ran/Library/CloudStorage/Dropbox/1\ project\ 3/package")
here::i_am("build_package.R")
# documentation
setwd("./MoCo")
usethis::use_data(data, overwrite = TRUE)
# load the package
devtools::load_all()
# install the r package
devtools::install()
# library
library(MoCo)
library(SuperLearner)
# load data
data(data)
# inspect data
str(data)
mean(data$Delta_Y)
# motion-controlled average functional connectivity
round(result$est, 4)
# inspect data
str(data)
# specify covariates
X = data$X
Z = data$Z
A = data$A
M = data$M
Y = data$Y
Delta_M = data$Delta_M
Delta_Y = data$Delta_Y
# computing motion-controlled average functional connectivity and associations
begin_time = Sys.time()
result = moco(
X = data$X,
Z = data$Z,
A = data$A,
M = data$M,
Y = data$Y,
Delta_M = data$Delta_M,
Delta_Y = data$Delta_Y,
SL_library = c("SL.mean", "SL.glm","SL.glm.interaction"),
glm_formula = list(pMX = ".",
pMXZ = "."),
HAL_pMX = FALSE,
HAL_pMXZ = FALSE,
cross_fit = TRUE,
cv_folds = 5,
seed_rgn = 1,
test = TRUE,
fwer = 0.05
)
end_time = Sys.time()
begin_time - end_time
# inspect the result
str(result)
# motion-controlled average functional connectivity
round(result$est, 4)
# motion-controlled association
round(result$adj_association, 4)
# z-scores
round(result$z_score, 4)
# significant regions
result$significant_regions
load("/Users/scarlett_ran/Library/CloudStorage/Dropbox/1\ longitudinal/abcd/code/gen_Y/motion/subj_List_pass_qc_gsrpowerbasic0.2.RData")
length(subj_List_pass_qc)
# define a grid of parameters for the simulation
# 100 replicates at each sample size in each setting
parms = expand.grid(q = 10:20,
phi = seq(1, 18, 0.5),
phi_ini = c(2, 3, 4),
espli = c(0.05, 0.01),
rho = c(0.9, 0.95))
# define a grid of parameters for the simulation
# 100 replicates at each sample size in each setting
parms = expand.grid(q = 10:20,
phi = seq(2, 18, 0.5),
phi_ini = c(2, 3, 4),
espli = c(0.05, 0.01),
rho = c(0.9, 0.95))
# define a grid of parameters for the simulation
# 100 replicates at each sample size in each setting
parms = expand.grid(q = 10:20,
phi = seq(1, 18, 0.5),
phi_ini = c(2, 3, 4),
espli = c(0.05, 0.01),
rho = c(0.9, 0.95))
# builing r package dlocus
library(devtools)
library(roxygen2)
# set working directory
setwd("/Users/scarlett_ran/Library/CloudStorage/Dropbox/1\ project\ 3/package")
here::i_am("build_package.R")
# documentation
setwd("./MoCo")
devtools::document()
# library
library(MoCo)
library(SuperLearner)
# load data
data(data)
# inspect data
str(data)
mean(data$Delta_Y)
# import the data
load("/Users/scarlett_ran/Library/CloudStorage/Dropbox/1\ project\ 3/tutorial/data/data.Rdata")
usethis::use_data(data, overwrite = TRUE)
# load the package
devtools::load_all()
# install the r package
devtools::install()
